"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault").default;
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MinimalTreeViewStore = void 0;
var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));
var _store = require("@mui/x-internals/store");
var _warning = require("@mui/x-internals/warning");
var _EventManager = require("@mui/x-internals/EventManager");
var _MinimalTreeViewStore = require("./MinimalTreeViewStore.utils");
var _TimeoutManager = require("./TimeoutManager");
var _keyboardNavigation = require("../plugins/keyboardNavigation");
var _TreeViewFocusPlugin = require("../plugins/focus/TreeViewFocusPlugin");
var _TreeViewItemsPlugin = require("../plugins/items/TreeViewItemsPlugin");
var _TreeViewSelectionPlugin = require("../plugins/selection/TreeViewSelectionPlugin");
var _expansion = require("../plugins/expansion");
var _TreeViewItemPluginManager = require("./TreeViewItemPluginManager");
class MinimalTreeViewStore extends _store.Store {
  initialParameters = null;
  eventManager = new _EventManager.EventManager();
  timeoutManager = new _TimeoutManager.TimeoutManager();
  itemPluginManager = new _TreeViewItemPluginManager.TreeViewItemPluginManager();
  constructor(parameters, instanceName, mapper) {
    const minimalInitialState = (0, _MinimalTreeViewStore.createMinimalInitialState)(parameters);
    const initialState = mapper.getInitialState(minimalInitialState, parameters);
    super(initialState);
    this.parameters = parameters;
    this.instanceName = instanceName;
    this.mapper = mapper;

    // We mount the plugins in the constructor to make sure all the methods of the store are available to the plugins during their construction.
    this.items = new _TreeViewItemsPlugin.TreeViewItemsPlugin(this);
    this.focus = new _TreeViewFocusPlugin.TreeViewFocusPlugin(this);
    this.expansion = new _expansion.TreeViewExpansionPlugin(this);
    this.selection = new _TreeViewSelectionPlugin.TreeViewSelectionPlugin(this);
    this.keyboardNavigation = new _keyboardNavigation.TreeViewKeyboardNavigationPlugin(this);
    if (process.env.NODE_ENV !== 'production') {
      this.initialParameters = parameters;
    }
  }

  /**
   * Builds an object containing the method that should be exposed publicly by the Tree View components.
   */
  buildPublicAPI() {
    return (0, _extends2.default)({}, this.items.buildPublicAPI(), this.focus.buildPublicAPI(), this.expansion.buildPublicAPI(), this.selection.buildPublicAPI());
  }

  /**
   * Updates the state of the Tree View based on the new parameters provided to the root component.
   */
  updateStateFromParameters(parameters) {
    const updateModel = (mutableNewState, controlledProp, defaultProp) => {
      if (parameters[controlledProp] !== undefined) {
        mutableNewState[controlledProp] = parameters[controlledProp];
      }
      if (process.env.NODE_ENV !== 'production') {
        const defaultValue = parameters[defaultProp];
        const isControlled = parameters[controlledProp] !== undefined;
        const initialDefaultValue = this.initialParameters?.[defaultProp];
        const initialIsControlled = this.initialParameters?.[controlledProp] !== undefined;
        if (initialIsControlled !== isControlled) {
          (0, _warning.warnOnce)([`MUI X Tree View: A component is changing the ${initialIsControlled ? '' : 'un'}controlled ${controlledProp} state of ${this.instanceName} to be ${initialIsControlled ? 'un' : ''}controlled.`, 'Elements should not switch from uncontrolled to controlled (or vice versa).', `Decide between using a controlled or uncontrolled ${controlledProp} element for the lifetime of the component.`, "The nature of the state is determined during the first render. It's considered controlled if the value is not `undefined`.", 'More info: https://fb.me/react-controlled-components'], 'error');
        } else if (JSON.stringify(initialDefaultValue) !== JSON.stringify(defaultValue)) {
          (0, _warning.warnOnce)([`MUI X Tree View: A component is changing the default ${controlledProp} state of an uncontrolled ${this.instanceName} after being initialized. `, `To suppress this warning opt to use a controlled ${this.instanceName}.`], 'error');
        }
      }
    };
    const newMinimalState = (0, _MinimalTreeViewStore.deriveStateFromParameters)(parameters);
    updateModel(newMinimalState, 'expandedItems', 'defaultExpandedItems');
    updateModel(newMinimalState, 'selectedItems', 'defaultSelectedItems');
    if (this.state.providedTreeId !== parameters.id || this.state.treeId === undefined) {
      newMinimalState.treeId = (0, _MinimalTreeViewStore.createTreeViewDefaultId)();
    }
    if (!this.mapper.shouldIgnoreItemsStateUpdate(parameters) && _TreeViewItemsPlugin.TreeViewItemsPlugin.shouldRebuildItemsState(parameters, this.parameters)) {
      Object.assign(newMinimalState, _TreeViewItemsPlugin.TreeViewItemsPlugin.buildItemsStateIfNeeded(parameters));
    }
    const newState = this.mapper.updateStateFromParameters(newMinimalState, parameters, updateModel);
    this.update(newState);
    this.parameters = parameters;
  }

  /**
   * Returns a cleanup function that need to be called when the store is destroyed.
   */
  disposeEffect = () => {
    return this.timeoutManager.clearAll;
  };

  /**
   * Whether updates based on `props.items` change should be ignored.
   */
  shouldIgnoreItemsStateUpdate = () => {
    return this.mapper.shouldIgnoreItemsStateUpdate(this.parameters);
  };

  /**
   * Registers an effect to be run when the value returned by the selector changes.
   */
  registerStoreEffect = (selector, effect) => {
    let previousValue = selector(this.state);
    this.subscribe(state => {
      const nextValue = selector(state);
      if (nextValue !== previousValue) {
        effect(previousValue, nextValue);
        previousValue = nextValue;
      }
    });
  };

  /**
   * Publishes an event to all its subscribers.
   */
  publishEvent = (name, params, event) => {
    if (isSyntheticEvent(event) && event.isPropagationStopped()) {
      return;
    }
    this.eventManager.emit(name, params, event);
  };

  /**
   * Subscribe to an event emitted by the store.
   * For now, the subscription is only removed when the store is destroyed.
   */
  subscribeEvent = (eventName, handler) => {
    this.eventManager.on(eventName, handler);
  };
}
exports.MinimalTreeViewStore = MinimalTreeViewStore;
function isSyntheticEvent(event) {
  return event?.isPropagationStopped !== undefined;
}